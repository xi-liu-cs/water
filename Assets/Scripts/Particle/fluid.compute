#pragma kernel malloc_particle

struct particle
{
    float3 position;
    float4 color;
};

RWStructuredBuffer<particle> particles;
RWStructuredBuffer<float> density,
pressure;
RWStructuredBuffer<float3> force,
velocity;
RWStructuredBuffer<int> neighbor_list,
neighbor_per_particle,
hash_grid,
particle_per_grid;

float grid_size;
int n_particle,
dimension,
max_particle_per_grid;

int3 grid(float3 position)
{
    return int3(position.x / grid_size, position.y / grid_size, position.z / grid_size);
}

int hash(int3 grid)
{
    return grid.x + dimension * (grid.y + dimension * grid.z);
}

[numthreads(1, 1, 1)]
void malloc_particle(uint3 id : SV_DispatchThreadID)
{
    int particle_per_dimension = pow(abs(n_particle), 1.0 / 3.0),
    i = 0;
    while(i < n_particle)
    {
        for(int x = 0; x < particle_per_dimension; ++x)
            for(int y = 0; y < particle_per_dimension; ++y)
                for(int z = 0; z < particle_per_dimension; ++z)
                {
                    float3 pos = float3(dimension - 1, dimension - 1, dimension - 1);
                    particles[i].position = pos;
                    particles[i].color = float4(30, 100, 255, 255);
                    if(++i == n_particle) return;
                }
    }
}

[numthreads(100, 1, 1)]
void clear_hash_grid(uint3 id : SV_DispatchThreadID)
{
    particle_per_grid[id.x] = 0;
}

[numthreads(100, 1, 1)]
void compute_hash_grid(uint3 id : SV_DispatchThreadID)
{
    int original_value = 0,
    hash_grid_position = hash(grid(particles[id.x].position));
    InterlockedAdd(particle_per_grid[hash_grid_position], 1, original_value); /* 'original_value' is an output variable that will be set to the original value of dest */
    if(original_value >= max_particle_per_grid)
    {
        particles[id.x].color = float4(255, 0, 0, 255);
        return;
    }
    hash_grid[hash_grid_position * max_particle_per_grid + original_value] = id.x;
}

void set_neighbor_key(int3 origin_index, float3 position, int neighbor_key[8])
{
    
}