#include "../Noise/noise.cginc"
#pragma kernel density

struct particle
{
    float3 position;
    float4 color;
};

RWStructuredBuffer<particle> particles;
RWStructuredBuffer<float4> points;
StructuredBuffer<float3> offsets;
int n_thread = 8,
n_point_per_axis,
octave;
float lacunarity,
persistence,
noise_scale,
noise_weight,
floor_offset,
weight_multiplier,
hard_floor,
hard_floor_weight,
spacing,
bound_size;
bool close_edge;
float3 center,
offset,
world_size;
float4 param;

int index_from_coordinate(int x, int y, int z)
{
    return x * n_point_per_axis * n_point_per_axis + y * n_point_per_axis + z;
}

[numthreads(n_thread, n_thread, n_thread)]
void density(int3 id : SV_DispatchThreadID)
{
    if(id.x >= n_point_per_axis || id.y >= n_point_per_axis || id.z >= n_point_per_axis)
        return;
    int index = index_from_coordinate(id.x, id.y, id.z);
    float3 pos = particles[index].position;
    float noise = 0,
    offset_noise = 0,
    frequency = noise_scale * 0.01,
    amplitude = 1,
    weight = 1;
    for(int i = 0; i < octave; ++i)
    {
        float n = snoise((pos + offset_noise) * frequency + offsets[i]),
        v = 1 - abs(n);
        v *= v * weight;
        weight = max(min(weight_multiplier * v, 1), 0);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    float density_value = -(pos.y + floor_offset) + noise * noise_weight + (pos.y % param.x) * param.y;
    if(pos.y < hard_floor) density_value += hard_floor_weight;
    if(close_edge)
    {
        float3 edge_offset = abs(2 * pos) - world_size + spacing / 2;
        float edge_weight = saturate(sign(max(max(edge_offset.x, edge_offset.y), edge_offset.z)));
        density_value = density_value * (1 - edge_weight) - 100 * edge_weight;
    }
    points[index] = float4(pos, density_value);
}