#include "../Noise/noise.cginc"

#define _BLOCK_SIZE 1024

// == VARIABLES ==
float gridCellSize;                             // float CellSize                               -- VERIFIED
int3 numCellsPerAxis;
float3 origin;
int3 dimension;                                 // int Dimensions                               -- VERIFIED
float3 bounds;
float3 outerBounds;
uint max_particles_per_grid;                    // int maximumParticlesPerCell;                 -- UINT VS INT
float smoothingRadius;                               // float radius;                                -- VERIFIED
float radius2;                                  // float radius2;                               -- VERIFIED
float radius3;                                  // float radius3;                               -- VERIFIED
float radius4;                                  // float radius4;                               -- VERIFIED
float radius5;                                  // float radius5;                               -- VERIFIED
float radius6;
float radius9;
float particleMass;                             // float mass;                                  -- VERIFIED
float mass2;                                    // float mass2;                                 -- VERIFIED
float gas_constant;                             // float gasConstant;                           -- VERIFIED
float rest_density;                             // float restDensity;                           -- VERIFIED
float viscosity_coefficient;                    // float viscosityCoefficient;                  -- VERIFIED
float damping;                                  // float damping;                               -- VERIFIED
float dt;                                       // float dt;                                    -- VERIFIED
float epsilon;                                  // float epsilon;                               -- VERIFIED
float3 g;                                       // float3 g;                                    -- VERIFIED
float pi;                                       // float pi;                                    -- VERIFIED
uint n;                                         // 8                                            -- HARD-CODED IN ORIGINAL SCRIPT

float e;
uint numParticles;
float4 time;
uint total_number_of_cells;
uint numBlocks;
uint d;
int randomSeed;
int state;
float particleRenderRadius;

// == STRUCTS ==
struct particle {
    float3 position;
    int3 grid_indices;
    int projected_index;
    uint offset;
    int index;
    int numNeighbors;
};

// == BUFFERS ==
RWStructuredBuffer<particle> particles;         // RWStructuredBuffer<Particle> _particles;     -- VERIFIED
RWStructuredBuffer<int> neighbor_list;          // RWStructuredBuffer<int> _neighbourList;      -- VERIFIED
//neighbors of a particle at particle_index * max_particles_per_grid * 8  
RWStructuredBuffer<int> neighbor_tracker;       // RWStructuredBuffer<int> _neighbourTracker;    -- VERIFIED
// number of neighors does each particle have
RWStructuredBuffer<uint> hash_grid;             // RWStructuredBuffer<uint> _hashGrid;          -- VERIFIED
// aligned at particle_index * max_particles_per_grid * 8' + hash_grid_tracker[particle_index]
RWStructuredBuffer<uint> hash_grid_tracker;     // RWStructuredBuffer<uint> _hashGridTracker;   -- VERIFIED
// number of particles at each grid
RWStructuredBuffer<float> density;              // RWStructuredBuffer<float> _densities;        -- VERIFIED
RWStructuredBuffer<float> pressure;             // RWStructuredBuffer<float> _pressures;        -- VERIFIED
RWStructuredBuffer<float3> velocity;            // RWStructuredBuffer<float3> _velocities;      -- VERIFIED
RWStructuredBuffer<float3> force;               // RWStructuredBuffer<float3> _forces;          -- VERIFIED
RWStructuredBuffer<float> kernel_sums;

RWStructuredBuffer<int> grid;
RWStructuredBuffer<int> gridOffsetBufferIn;
RWStructuredBuffer<int> gridOffsetBuffer;
RWStructuredBuffer<int> gridSumsBuffer;
RWStructuredBuffer<int> gridSumsBufferIn;
RWStructuredBuffer<particle> rearrangedParticles;
RWStructuredBuffer<int> numNeighbors;
RWStructuredBuffer<float3> storedVelocities;

// int3 GetCell -- VERIFIED
int3 GetGridXYZIndices(float3 position) {
    return int3(
        floor((position[0] - (origin[0] - (numCellsPerAxis[0] * gridCellSize)/2.0))/gridCellSize),
        floor((position[1] - (origin[1] - (numCellsPerAxis[1] * gridCellSize)/2.0))/gridCellSize),
        floor((position[2] - (origin[2] - (numCellsPerAxis[2] * gridCellSize)/2.0))/gridCellSize)
    );
}

// int Hash -- VERIFIED
int GetProjectedGridIndexFromXYZ(int3 xyz) {
    return xyz.x + (numCellsPerAxis[0] * xyz.y) + (numCellsPerAxis[0] * numCellsPerAxis[1] * xyz.z);
}

#pragma kernel GenerateGrid
[numthreads(_BLOCK_SIZE,1,1)]
void GenerateGrid(uint3 id : SV_DispatchThreadID) {
  if (id.x >= total_number_of_cells) return;
  grid[id.x] = 0;
}

// Basic random generation
float wangHash() {
  state = (state ^ 61) ^(state >> 16);
  state *= 9;
  state = state ^(state >> 4);
  state *= 0x27d4eb2d;
  state = state ^(state >> 15);
  return state / 4294967296.0;
}

float randRange(float a, float b) {
  return wangHash() * (b - a) + a;
}

#pragma kernel GenerateParticles
[numthreads(_BLOCK_SIZE, 1, 1)]
void GenerateParticles(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    
    state = randomSeed + id.x;
    /*float3 position = float3(
        randRange(float(bound[0]), float(bound[1])), 
        randRange(float(bound[2]), float(bound[3])), 
        randRange(float(bound[4]), float(bound[5]))
    );
    */
    float3 position = 
        origin 
        //+ float3(float(bounds[0]/2.0-1),float(bounds[1]/2.0-1),float(bounds[2]/2.0-1)) 
        + float3(
            randRange(float(-bounds[0]/2.0), float(bounds[0]/2.0)), 
            randRange(float(-bounds[1]/2.0), float(bounds[1]/2.0)), 
            randRange(float(-bounds[2]/2.0), float(bounds[2]/2.0))
        )
        - float3(
            randRange(float(0),float(0.01)),
            randRange(float(0),float(0.01)),
            randRange(float(0),float(0.01))
        );
    int3 grid_indices = GetGridXYZIndices(position);
    int projected_index = GetProjectedGridIndexFromXYZ(grid_indices);
    particles[id.x].position = position;
    particles[id.x].grid_indices = grid_indices;
    particles[id.x].projected_index = projected_index;
    particles[id.x].index = id.x;
    density[id.x] = 0;
    pressure[id.x] = 0;
    force[id.x] = float3(0,0,0);
    velocity[id.x] = float3(0,-50,0);
}

#pragma kernel ClearGrid
[numthreads(_BLOCK_SIZE, 1, 1)]
void ClearGrid(uint3 id : SV_DispatchThreadID) {
    if (id.x > total_number_of_cells) return;
    grid[id.x] = 0;
}

#pragma kernel ResetNumNeighbors
[numthreads(_BLOCK_SIZE,1,1)]
void ResetNumNeighbors(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    numNeighbors[id.x] = 0;
}

#pragma kernel UpdateGridCellCounts
[numthreads(_BLOCK_SIZE,1,1)]
void UpdateGridCellCounts(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    particle p = particles[id.x];
    int3 grid_indices = GetGridXYZIndices(p.position);
    int projected_index = GetProjectedGridIndexFromXYZ(grid_indices);
    p.grid_indices = grid_indices;
    p.projected_index = projected_index;
    InterlockedAdd(grid[projected_index], 1, p.offset);
    p.numNeighbors = 0;
    particles[id.x] = p;
}

#pragma kernel PrefixSum
groupshared int temp[_BLOCK_SIZE * 2];
[numthreads(_BLOCK_SIZE, 1, 1)]
void PrefixSum(uint projectedCellID : SV_DispatchThreadID, uint threadID : SV_GroupThreadID, uint groupID : SV_GroupID) {
    int pout = 0;
    int pin = 1;
    // Our input is `grid`
    temp[threadID] = gridOffsetBufferIn[projectedCellID];
    GroupMemoryBarrierWithGroupSync();

    [unroll]
    for(uint offset = 1; offset < _BLOCK_SIZE; offset *= 2) {
        pout = 1 - pout;
        pin = 1 - pin;
        if (threadID >= offset) {
            temp[pout * _BLOCK_SIZE + threadID] = temp[pin * _BLOCK_SIZE + threadID] + temp[pin * _BLOCK_SIZE + threadID - offset];
        } else {
            temp[pout * _BLOCK_SIZE + threadID] = temp[pin * _BLOCK_SIZE + threadID];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if (projectedCellID >= total_number_of_cells) return;

    // We output to `gridOffsetBuffer`
    gridOffsetBuffer[projectedCellID] = temp[pout * _BLOCK_SIZE + threadID];
    if (threadID == 0) {
        // We output to `gridSumsBuffer2`
        gridSumsBuffer[groupID] = temp[pout * _BLOCK_SIZE + _BLOCK_SIZE - 1];
    }
}

#pragma kernel SumBlocks
[numthreads(_BLOCK_SIZE, 1, 1)]
void SumBlocks(uint3 id : SV_DISPATCHTHREADID) {
  if (id.x >= numBlocks) return;
  uint k = id.x;
  if (k < d) gridSumsBuffer[k] = gridSumsBufferIn[k];
  else gridSumsBuffer[k] = gridSumsBufferIn[k] + gridSumsBufferIn[k - d];
}

#pragma kernel AddSums
[numthreads(_BLOCK_SIZE, 1, 1)]
void AddSums(uint projectedGridIndex : SV_DispatchThreadID, uint groupID : SV_GroupID) {
  if (groupID == 0 || projectedGridIndex > total_number_of_cells) return;
  // Output to `gridOffsetBuffer`
  gridOffsetBuffer[projectedGridIndex] += gridSumsBufferIn[groupID - 1];
}

#pragma kernel RearrangeParticles
[numthreads(_BLOCK_SIZE, 1, 1)]
void RearrangeParticles(uint3 id : SV_DispatchThreadID) {
  if (id.x >= numParticles) return;
  
  int projectedGridIndex = particles[id.x].projected_index;
  int cellOffset = particles[id.x].offset;
  int index = gridOffsetBuffer[projectedGridIndex] - 1 - cellOffset;
  rearrangedParticles[index] = particles[id.x];
}

#pragma kernel CountNumNeighbors
[numthreads(_BLOCK_SIZE,1,1)]
void CountNumNeighbors(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    particle p = particles[id.x];
    int zStep = numCellsPerAxis[0] * numCellsPerAxis[1];
    for (int z = p.projected_index - zStep; z <= p.projected_index + zStep; z += zStep) {
        for (int y = z - numCellsPerAxis[0]; y <= z + numCellsPerAxis[0]; y += numCellsPerAxis[0]) {
            int start = gridOffsetBuffer[y - 2];
            int end = gridOffsetBuffer[y + 1];
            for (int i = start; i < end; i++) {
                particle otherP = rearrangedParticles[i];
                //if (otherP.index == p.index) continue;
                float dist = length(otherP.position - p.position);
                if (dist <= smoothingRadius) {
                    p.numNeighbors += 1;
                    numNeighbors[id.x] += 1;
                }
            }
        }
    }
    particles[id.x] = p;
}

float std_kernel(float distance_square) {
    float x = float(1) - distance_square / radius2;
    return float(315) / (float(64) * pi * radius3) * x * x * x;
}

float spiky_kernel_first_derivative(float distance) {
    float x = float(1) - distance / smoothingRadius;
    return float(-45) / (pi * radius4) * x * x;
}

float spiky_kernel_second_derivative(float distance) {
    float x = float(1) - distance / smoothingRadius;
    return float(90) / (pi * radius5) * x;
}

float3 spiky_kernel_gradient(float distance, float3 direction_from_center) {
    return spiky_kernel_first_derivative(distance) * direction_from_center;
}

float DensityKernel(float h, float r) {
    float diff = h*h - r*r;
    return (315.0 / (64.0 * pi * radius9)) * diff * diff * diff;
}
float GetDensity(float currentDensity, float dist) {
    // If 0 <= distance <= smoothing radius:
    if (dist < smoothingRadius) return particleMass * DensityKernel(smoothingRadius, dist);
    // If not, we simply return current density
    return 0.0;
}

#pragma kernel ComputeDensityPressure
[numthreads(_BLOCK_SIZE, 1, 1)]
void ComputeDensityPressure(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    
    particle p = particles[id.x];

    float3 origin = p.position;
    float _density = 0.0;
    float _pressure = 0.0;

        int zStep = numCellsPerAxis[0] * numCellsPerAxis[1];
        for (int z = p.projected_index - zStep; z <= p.projected_index + zStep; z += zStep) {
            for (int y = z - numCellsPerAxis[0]; y <= z + numCellsPerAxis[0]; y += numCellsPerAxis[0]) {
                int start = gridOffsetBuffer[y - 2];
                int end = gridOffsetBuffer[y + 1];

                for (int i = start; i < end; i++) {
                    // Get the other neighbor particle
                    particle otherP = rearrangedParticles[i];
                    // If the indexes match, that means they're the same. Ignore it!
                    //if (otherP.index == id.x) continue;
                    // Get the direction to the other particle from the current particle
                    float3 dir = otherP.position - origin;
                    // Get the distance between the current and other particle's centers
                    float dist = length(dir);
                    // Determine the new density, given these parameters
                    _density += GetDensity(_density, dist);
                    // Determine pressure
                    _pressure = gas_constant * (_density - rest_density);
                }
            }
        
    }
    if (_density == 0.0) density[id.x] = 0.000001;
    else density[id.x] = _density;
    pressure[id.x] = _pressure;
}

float PressureKernel(float h, float r) {
    float dist = h - r;
    return (15 / (pi * radius6)) * dist * dist * dist; 
}
float3 GetPressureForce(particle currentParticle, particle neighborParticle, float3 direction, float dist) {
    // If the distance fits within the smoothing radius:
    if (dist < smoothingRadius) {
        float3 normalizedDir = float3(0,0,0);
        if (dist != 0.0) {
            normalizedDir = direction / dist;
        }
        return -1.0 * (normalizedDir) 
            * particleMass 
            * (
                (pressure[currentParticle.index] + pressure[neighborParticle.index]) 
                / (2.0 * density[neighborParticle.index]) 
            )
            * PressureKernel(smoothingRadius, dist);
    }
    // otherwise, return empty float3
    return float3(0,0,0);
}
float ViscosityKernel(float h, float r) {
    return (45.0 / (pi * radius6)) * (h * r);
}
float3 GetViscosityForce(particle currentParticle, particle neighborParticle, float dist) {
    // If the distance fits within the smoothing radius:
    if (dist < smoothingRadius) {
        return viscosity_coefficient 
            * particleMass 
            * (
                (velocity[neighborParticle.index] - velocity[currentParticle.index]) / density[neighborParticle.index] 
            )
            * ViscosityKernel(smoothingRadius, dist);
    }
    // Otherwise, return empty float3
    return float3(0,0,0);
}

#pragma kernel ComputeForce
[numthreads(_BLOCK_SIZE, 1, 1)]
void ComputeForce(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    particle p = particles[id.x];
    
    float3 forcePressure = float3(0,0,0);
    float3 forceViscosity = float3(0,0,0);
    float3 forceGravity = g * density[id.x];

    int zStep = numCellsPerAxis[0] * numCellsPerAxis[1];
    for (int z = p.projected_index - zStep; z <= p.projected_index + zStep; z += zStep) {
        for (int y = z - numCellsPerAxis[0]; y <= z + numCellsPerAxis[0]; y += numCellsPerAxis[0]) {
            int start = gridOffsetBuffer[y - 2];
            int end = gridOffsetBuffer[y + 1];
            for (int i = start; i < end; i++) {
                // Get the other particle
                particle otherP = rearrangedParticles[i];
                // Skip if we encountered each other
                if (otherP.index == p.index) continue;

                // get the direction to the other neighbor from the current particle
                float3 dir = otherP.position - p.position;
                // Get the distance between the centers of the two particles
                float dist = length(dir);
                // Calculate pressure force
                forcePressure += GetPressureForce(p, otherP, dir, dist);
                // Calcualte viscosity force
                forceViscosity += GetViscosityForce(p, otherP, dist);
            }
        }
    }
    // Determine the combined force
    force[id.x] = forcePressure + forceViscosity + forceGravity;
}

#pragma kernel Integrate
[numthreads(_BLOCK_SIZE, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;

    particle p = particles[id.x];
    float3 v = velocity[id.x];

    v += dt * (force[id.x] / density[id.x]);
    p.position += dt * v;
    
    particles[id.x] = p;
    velocity[id.x] = v;
    storedVelocities[id.x] = v;
}

#pragma kernel ComputeCollisions
[numthreads(_BLOCK_SIZE,1,1)]
void ComputeCollisions(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    particle p = particles[id.x];
    float3 newVel = float3(0,0,0);
    int numCollisions = 0;
    int zStep = numCellsPerAxis[0] * numCellsPerAxis[1];
    for (int z = p.projected_index - zStep; z <= p.projected_index + zStep; z += zStep) {
        for (int y = z - numCellsPerAxis[0]; y <= z + numCellsPerAxis[0]; y += numCellsPerAxis[0]) {
            int start = gridOffsetBuffer[y - 2];
            int end = gridOffsetBuffer[y + 1];
            for (int i = start; i < end; i++) {
                // Get the other particle
                particle otherP = rearrangedParticles[i];
                // Skip if we encountered each other
                if (otherP.index == p.index) continue;
                // To check for collision, we look at the rendered radius this time.
                // Calculate the distances between the centers
                float dist = distance(otherP.position, p.position) + 0.01;
                float3 dirAway = p.position - otherP.position;
                if (length(dirAway) == 0.0) dirAway = float3(0,1,0);
                else dirAway /= length(dirAway);
                // If the distances between centers is less than the radii of the two particles added, then we got a collision
                if (dist <= particleRenderRadius*2.0) {
                    // We'll just do elastic collision. AKA switch the velocities around. This presumes particles are of same mass.
                    newVel += storedVelocities[otherP.index];
                    p.position += dirAway * (particleRenderRadius - (dist - particleRenderRadius));
                    numCollisions += 1;
                }
            }
        }
    }
    if (numCollisions > 0) velocity[id.x] = newVel / float(numCollisions);
}

#pragma kernel DampenByBounds
[numthreads(_BLOCK_SIZE,1,1)]
void DampenByBounds(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    
    particle p = particles[id.x];
    float3 v = velocity[id.x];

    if(particles[id.x].position.x - particleRenderRadius < -bounds[0]/2.0 + epsilon) {
        v[0] *= damping;
        p.position.x = -bounds[0]/2.0 + particleRenderRadius + epsilon;
    }
    else if(particles[id.x].position.x + particleRenderRadius > bounds[0]/2.0 - epsilon) {
        v[0] *= damping;
        p.position.x = bounds[0]/2.0 - particleRenderRadius - epsilon;
    }

    if(particles[id.x].position.y - particleRenderRadius < -bounds[1]/2.0 + epsilon) {
        v[1] *= damping;
        p.position.y = -bounds[1]/2.0 + particleRenderRadius + epsilon;
    }
    else if(particles[id.x].position.y + particleRenderRadius > bounds[1]/2.0 - epsilon) {
        v[1] *= damping;
        p.position.y = bounds[1]/2.0 - particleRenderRadius - epsilon;
    }

    if(particles[id.x].position.z - particleRenderRadius < -bounds[2]/2.0 + epsilon) {
        v[2] *= damping;
        p.position.z = -bounds[2]/2.0 + particleRenderRadius + epsilon;
    }
    else if(particles[id.x].position.z + particleRenderRadius > bounds[2]/2.0 - epsilon) {
        v[2] *= damping;
        p.position.z = bounds[2]/2.0 - particleRenderRadius - epsilon;
    }

    velocity[id.x] = v;
    particles[id.x] = p;
}