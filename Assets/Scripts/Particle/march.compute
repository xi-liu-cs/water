#include "march_table.compute"
#pragma kernel march
static const int n_thread = 8;

struct tri
{
    float3 vertex_a,
    vertex_b,
    vertex_c;
};

AppendStructuredBuffer<tri> triangles;
RWStructuredBuffer<float4> points;
int n_point_per_axis;
float isolevel;

float3 interpolate_vertex(float4 v1, float4 v2)
{
    float t = (isolevel - v1.w) / (v2.w - v1.w);
    return v1.xyz + t * (v2.xyz - v1.xyz);
}

int index_from_coordinate(int x, int y, int z)
{
    return x * n_point_per_axis * n_point_per_axis + y * n_point_per_axis + z;
}

[numthreads(n_thread, n_thread, n_thread)]
void march(int3 id : SV_DispatchThreadID)
{
    if(id.x >= n_point_per_axis - 1 || id.y >= n_point_per_axis - 1 || id.z >= n_point_per_axis - 1) /* voxel includes neighbor points */
        return;
    float4 cube_corner[] =
    {
        points[index_from_coordinate(id.x, id.y, id.z)],
        points[index_from_coordinate(id.x + 1, id.y, id.z)],
        points[index_from_coordinate(id.x + 1, id.y, id.z + 1)],
        points[index_from_coordinate(id.x, id.y, id.z + 1)],
        points[index_from_coordinate(id.x, id.y + 1, id.z)],
        points[index_from_coordinate(id.x + 1, id.y + 1, id.z)],
        points[index_from_coordinate(id.x + 1, id.y + 1, id.z + 1)],
        points[index_from_coordinate(id.x, id.y + 1, id.z + 1)]
    };
    int n_corner = 8,
    cube_index = 0;
    for(int i = 0; i < n_corner; ++i)
        if(cube_corner[i].w < isolevel) /* if the input data is not binary, need an additional parameter (threshold value or isovalue) to classify samples as inside or outside the surface */
            cube_index |= 1 << i;
    for(int i = 0; triangle_table[cube_index][i] != -1; i += 3)
    {
        int a1 = corner_index_a_from_edge[triangle_table[cube_index][i]],
        b1 = corner_index_b_from_edge[triangle_table[cube_index][i]],
        a2 = corner_index_a_from_edge[triangle_table[cube_index][i + 1]],
        b2 = corner_index_b_from_edge[triangle_table[cube_index][i + 1]],
        a3 = corner_index_a_from_edge[triangle_table[cube_index][i + 2]],
        b3 = corner_index_b_from_edge[triangle_table[cube_index][i + 2]];
        tri a;
        a.vertex_a = interpolate_vertex(cube_corner[a1], cube_corner[b1]);
        a.vertex_b = interpolate_vertex(cube_corner[a2], cube_corner[b2]);
        a.vertex_c = interpolate_vertex(cube_corner[a3], cube_corner[b3]);
        triangles.Append(a);
    }
}