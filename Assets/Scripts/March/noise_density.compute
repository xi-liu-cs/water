#pragma kernel compute_density
#include "noise.compute"

struct particle
{
    float3 position;
    float4 color;
};

static const int n = 8,
n_thread = 8,
max_particles_per_grid;

StructuredBuffer<float3> offsets;
int n_point_per_axis;
float boundsSize;
float3 center;
float3 offset;
float spacing;
float3 worldSize;
int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float floorOffset;
float weightMultiplier;
bool closeEdges;
float hardFloor;
float hardFloorWeight;
float mass,
radius,
radius2,
radius3,
pi;
RWStructuredBuffer<particle> particles;
RWStructuredBuffer<float> voxel_density;
RWStructuredBuffer<int> neighbor_list,
neighbor_tracker;

float4 params;

static const float e = 2.7182818284590452353602874713527;

float kernel(float x)
{
    return pow(1 - x * x, 3);
}

float std_kernel(float distance_square)
{
    float x = 1.0 - distance_square / radius2;
    return 315.0 / (64.0 * pi * radius3) * x * x * x;
}

int hash(uint x, uint y, uint z)
{
    return x + n_point_per_axis * (y + n_point_per_axis * z);
}

/* [numthreads(n_thread, n_thread, n_thread)]
void compute_density(int3 id : SV_DispatchThreadID)
{
    int index = hash(id.x, id.y, id.z);
    voxel_density[index] = abs(16 * snoise(particles[index].position));
} */

/* [numthreads(n_thread, n_thread, n_thread)]
void compute_density(int3 id : SV_DispatchThreadID)
{
    int index = hash(id.x, id.y, id.z);
    float3 origin = particles[index].position;
    float sum = 0;
    for(int i = 0; i < neighbor_tracker[index]; ++i)
    {
        int neighbor_index = neighbor_list[index * max_particles_per_grid * n + i];
        float3 diff = origin - particles[neighbor_index].position;
        float distance_square = dot(diff, diff);
        sum += std_kernel(distance_square);
    }
    voxel_density[index] = abs(sum * mass * 0.000000000001);
} */

/* [numthreads(n_thread, n_thread, n_thread)]
void compute_density(int3 id : SV_DispatchThreadID)
{
    int index = hash(id.x, id.y, id.z);
    float3 origin = particles[index].position;
    float sum = 0;
    for(int i = 0; i < neighbor_tracker[index]; ++i)
    {
        int neighbor_index = neighbor_list[index * max_particles_per_grid * n + i];
        float3 diff = origin - particles[neighbor_index].position;
        float distance_square = dot(diff, diff);
        sum += distance_square;
    }
    voxel_density[index] = sum / neighbor_tracker[index] * 0.0005;
} */

/* [numthreads(n_thread, n_thread, n_thread)]
void compute_density(int3 id : SV_DispatchThreadID)
{
    int index = hash(id.x, id.y, id.z);
    float3 origin = particles[index].position;
    float sum = 0,
    weight_divisor = 0,
    weight_div;
    for(int i = 0; i < neighbor_tracker[index]; ++i)
    {
        int neighbor_index = neighbor_list[index * max_particles_per_grid * n + i];
        float3 abs_diff = length(origin - particles[neighbor_index].position);
        weight_divisor += kernel(abs_diff / radius);
    }
    weight_div = 1 / weight_divisor;
    for(int i = 0; i < neighbor_tracker[index]; ++i)
    {
        int neighbor_index = neighbor_list[index * max_particles_per_grid * n + i];
        float3 abs_diff = length(origin - particles[neighbor_index].position);
        float weight_i = kernel(abs_diff / radius) * weight_div;
        sum += weight_i * length(origin - particles[neighbor_index].position);
    }
    voxel_density[index] = sum - radius;
} */

[numthreads(n_thread, n_thread, n_thread)]
void compute_density(int3 id : SV_DispatchThreadID)
{
    int index = hash(id.x, id.y, id.z);
    float3 pos = particles[index].position;
    float sum = 0;
    for(int i = 0; i < neighbor_tracker[index]; ++i)
    {
        int neighbor_index = neighbor_list[index * max_particles_per_grid * n + i];
        float r = length(pos - particles[neighbor_index].position);
        r *= 0.005;
        sum += pow(e, -r * r);
    }
    voxel_density[index] = sum;
}