#pragma kernel clear_cube_corner_neighbor_tracker
#pragma kernel compute_neighbor_list
#pragma kernel compute_density
#include "noise.compute"

// Copied from `fluid_shader_2.compute`
struct particle {
    float3 position;
};

static const int n = 8,
n_thread = 8;

StructuredBuffer<float3> offsets;
int n_point_per_axis;
float boundsSize;
float spacing;
float3 worldSize;
int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float floorOffset;
float weightMultiplier;
bool closeEdges;
float hardFloor;
float hardFloorWeight;

// World constants
float pi;
static const float e = 2.7182818284590452353602874713527; // Euler's constant

// Retrieved from `fluid_gpu.cs`
float gridCellSize;
float radius;
float radius2;
float radius3;
float particleRenderRadius;
float3 bounds;

float sphere_radius;
float4 params;

RWStructuredBuffer<particle> particles;
RWStructuredBuffer<float> voxel_density;
RWStructuredBuffer<float3> points;

RWStructuredBuffer<int> cube_corner_neighbor_list,
cube_corner_neighbor_tracker;
int max_particles_per_cube;

float kernel(float x) {
    return pow(1 - x * x, 3);
}

float std_kernel(float distance_square) {
    float x = 1.0 - distance_square / radius2;
    return 315.0 / (64.0 * pi * radius3) * x * x * x;
}

int hash(uint x, uint y, uint z) {
    return x + n_point_per_axis * (y + n_point_per_axis * z); /* n_point_per_axis, try sphere */
}

int3 get_cell(float3 position) {
    return int3(
        (position[0] - (bounds[0]/2.0)) / gridCellSize, 
        (position[1] - (bounds[1]/2.0)) / gridCellSize, 
        (position[2] - (bounds[2]/2.0)) / gridCellSize
    );
}

int hash_cell(int3 cell) {
    return cell.x + n_point_per_axis * (cell.y + n_point_per_axis * cell.z); /* n_point_per_axis, try sphere */
}


[numthreads(n_thread, n_thread, n_thread)]
void clear_cube_corner_neighbor_tracker(uint3 id : SV_DispatchThreadID) {
    cube_corner_neighbor_tracker[hash(id.x, id.y, id.z)] = 0;
}

[numthreads(n_thread, n_thread, n_thread)]
void compute_neighbor_list(uint3 id : SV_DispatchThreadID) {
    // Get the index of the current... particle?
    int index = hash(id.x, id.y, id.z);
    // Get the position of the current particle
    float3 pos = particles[index].position;
    // Get the XYZ coordinates of the current cell in the voxel grid
    int3 cell_index = get_cell(pos);

    // 
    int cube_corner_index = hash_cell(cell_index),
    original_value = 0;
    if(cube_corner_neighbor_tracker[cube_corner_index] + 1 > max_particles_per_cube) return;
    InterlockedAdd(cube_corner_neighbor_tracker[cube_corner_index], 1, original_value);
    if(original_value > max_particles_per_cube) return;
    cube_corner_neighbor_list[cube_corner_index * max_particles_per_cube + original_value] = index;

    int cube_corner_index2 = hash(cell_index[0], cell_index[1], cell_index[2] + 1),
    original_value2 = 0;
    if(cube_corner_neighbor_tracker[cube_corner_index2] + 1 > max_particles_per_cube) return;
    InterlockedAdd(cube_corner_neighbor_tracker[cube_corner_index2], 1, original_value2);
    if(original_value2 > max_particles_per_cube) return;
    cube_corner_neighbor_list[cube_corner_index2 * max_particles_per_cube + original_value2] = index;

    int cube_corner_index3 = hash(cell_index[0], cell_index[1] + 1, cell_index[2]),
    original_value3 = 0;
    if(cube_corner_neighbor_tracker[cube_corner_index3] + 1 > max_particles_per_cube) return;
    InterlockedAdd(cube_corner_neighbor_tracker[cube_corner_index3], 1, original_value3);
    if(original_value3 > max_particles_per_cube) return;
    cube_corner_neighbor_list[cube_corner_index3 * max_particles_per_cube + original_value3] = index;

    int cube_corner_index4 = hash(cell_index[0], cell_index[1] + 1, cell_index[2] + 1),
    original_value4 = 0;
    if(cube_corner_neighbor_tracker[cube_corner_index4] + 1 > max_particles_per_cube) return;
    InterlockedAdd(cube_corner_neighbor_tracker[cube_corner_index4], 1, original_value4);
    if(original_value4 > max_particles_per_cube) return;
    cube_corner_neighbor_list[cube_corner_index4 * max_particles_per_cube + original_value4] = index;

    int cube_corner_index5 = hash(cell_index[0] + 1, cell_index[1], cell_index[2]),
    original_value5 = 0;
    if(cube_corner_neighbor_tracker[cube_corner_index5] + 1 > max_particles_per_cube) return;
    InterlockedAdd(cube_corner_neighbor_tracker[cube_corner_index5], 1, original_value5);
    if(original_value5 > max_particles_per_cube) return;
    cube_corner_neighbor_list[cube_corner_index5 * max_particles_per_cube + original_value5] = index;

    int cube_corner_index6 = hash(cell_index[0] + 1, cell_index[1], cell_index[2] + 1),
    original_value6 = 0;
    if(cube_corner_neighbor_tracker[cube_corner_index6] + 1 > max_particles_per_cube) return;
    InterlockedAdd(cube_corner_neighbor_tracker[cube_corner_index6], 1, original_value6);
    if(original_value6 > max_particles_per_cube) return;
    cube_corner_neighbor_list[cube_corner_index6 * max_particles_per_cube + original_value6] = index;

    int cube_corner_index7 = hash(cell_index[0] + 1, cell_index[1] + 1, cell_index[2]),
    original_value7 = 0;
    if(cube_corner_neighbor_tracker[cube_corner_index7] + 1 > max_particles_per_cube) return;
    InterlockedAdd(cube_corner_neighbor_tracker[cube_corner_index7], 1, original_value7);
    if(original_value7 > max_particles_per_cube) return;
    cube_corner_neighbor_list[cube_corner_index7 * max_particles_per_cube + original_value7] = index;

    int cube_corner_index8 = hash(cell_index[0] + 1, cell_index[1] + 1, cell_index[2] + 1),
    original_value8 = 0;
    if(cube_corner_neighbor_tracker[cube_corner_index8] + 1 > max_particles_per_cube) return;
    InterlockedAdd(cube_corner_neighbor_tracker[cube_corner_index8], 1, original_value8);
    if(original_value8 > max_particles_per_cube) return;
    cube_corner_neighbor_list[cube_corner_index8 * max_particles_per_cube + original_value8] = index;
}

[numthreads(n_thread, n_thread, n_thread)]
void compute_density(int3 id : SV_DispatchThreadID) {
    if(
        id.x >= n_point_per_axis 
        || id.y >= n_point_per_axis 
        || id.z >= n_point_per_axis
    ) return;
    
    float3 cube_corner_pos = float3(
        -bounds[0]/2.0, 
        -bounds[1]/2.0, 
        -bounds[2]/2.0
    ) + id * gridCellSize;
    int cube_corner_index = hash_cell(id);
    float sum = 0,
    weight_divisor = 0,
    weight_multiplier;
    float3 average_particle_pos = float3(0, 0, 0);
    for(int i = 0; i < cube_corner_neighbor_tracker[cube_corner_index]; i++) {
        int neighbor_index = cube_corner_neighbor_list[cube_corner_index * max_particles_per_cube + i];
        weight_divisor += kernel(length(cube_corner_pos - particles[neighbor_index].position) / radius);
    }
    weight_multiplier = 1.0 / weight_divisor;
    for(int j = 0; j < cube_corner_neighbor_tracker[cube_corner_index]; j++) {
        int neighbor_index = cube_corner_neighbor_list[cube_corner_index * max_particles_per_cube + j];
        float x = length(cube_corner_pos - particles[neighbor_index].position) / radius,
        weight_i = weight_multiplier * kernel(x);
        average_particle_pos += weight_i * particles[neighbor_index].position;
    }
    points[cube_corner_index] = cube_corner_pos;
    voxel_density[cube_corner_index] = length(cube_corner_pos - average_particle_pos) - particleRenderRadius;
}